const eno = require('../eno.js');

describe('EnoDictionary', () => {
  describe('assertAllTouched', () => {

    let dictionary;

    beforeEach(() => {
      const document = eno.parse(`
        languages:
        eno = eno notation
      `);
      dictionary = document.dictionary('languages');
    });

    describe('when the only existing entry is not touched', () => {
      it('throws an error', () => {
        expect(() => dictionary.assertAllTouched()).toThrowErrorMatchingSnapshot();
      });

      describe('with a custom message string', () => {
        it('throws an error with my custom message', () => {
          expect(() => dictionary.assertAllTouched('my custom error')).toThrowErrorMatchingSnapshot();
        });
      });

      describe('with a custom message function', () => {
        it('throws an error generated by my custom message function', () => {
          expect(
            () => dictionary.assertAllTouched(({ name, value }) =>
              `my custom generated message for entry ${name} with value ${value}`
            )
          ).toThrowErrorMatchingSnapshot();
        });
      });

      describe("but not included in a provided 'only' option", () => {
        it('does not throw', () => {
          expect(() => dictionary.assertAllTouched({ only: ['other'] })).not.toThrow();
        });
      });

      describe("but excluded through the 'except' option", () => {
        it('does not throw', () => {
          expect(() => dictionary.assertAllTouched({ except: ['eno'] })).not.toThrow();
        });
      });
    });

    describe('when the only existing element is touched', () => {

      beforeEach(() => {
        const _ = dictionary.entry('eno');
      });

      it('does not throw', () => {
        expect(() => dictionary.assertAllTouched()).not.toThrow();
      });
    });
  });
});

describe('EnoSection', () => {
  describe('assertAllTouched', () => {

    let document;

    beforeEach(() => {
      document = eno.parse('language: eno');
    });

    describe('when the only existing element is not touched', () => {
      it('throws an error', () => {
        expect(() => document.assertAllTouched()).toThrowErrorMatchingSnapshot();
      });

      describe('with a custom message string', () => {
        it('throws an error with my custom message', () => {
          expect(() => document.assertAllTouched('my custom error')).toThrowErrorMatchingSnapshot();
        });
      });

      describe('with a custom message function', () => {
        it('throws an error generated by my custom message function', () => {
          expect(
            () => document.assertAllTouched(({ name, value }) =>
              `my custom generated message for element ${name} with value ${value}`
            )
          ).toThrowErrorMatchingSnapshot();
        });
      });

      describe("but not included in a provided 'only' option", () => {
        it('does not throw', () => {
          expect(() => document.assertAllTouched({ only: ['other'] })).not.toThrow();
        });
      });

      describe("but excluded through the 'except' option", () => {
        it('does not throw', () => {
          expect(() => document.assertAllTouched({ except: ['language'] })).not.toThrow();
        });
      });
    });

    describe('when the only existing element is touched', () => {

      beforeEach(() => {
        const _ = document.field('language');
      });

      it('does not throw', () => {
        expect(() => document.assertAllTouched()).not.toThrow();
      });
    });
  });
});

describe('Recursive assertAllTouched', () => {

  let document;

  beforeEach(() => {
    document = eno.parse(`
      languages:
      eno = eno notation
    `);
    const _ = document.dictionary('languages');
  });

  describe('when the only existing dictionary is touched, but not its single entry', () => {
    it('throws an error', () => {
      expect(() => document.assertAllTouched()).toThrowErrorMatchingSnapshot();
    });

    describe('with a custom message string', () => {
      it('throws an error with my custom message', () => {
        expect(() => document.assertAllTouched('my custom error')).toThrowErrorMatchingSnapshot();
      });
    });

    describe('with a custom message function', () => {
      it('throws an error generated by my custom message function', () => {
        expect(
          () => document.assertAllTouched(({ name, value }) =>
            `my custom generated message for element ${name} with value ${value}`
          )
        ).toThrowErrorMatchingSnapshot();
      });
    });
  });
});
